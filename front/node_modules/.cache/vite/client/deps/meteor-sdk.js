import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-TCQZMY3T.js";

// node_modules/wolfy87-eventemitter/EventEmitter.js
var require_EventEmitter = __commonJS({
  "node_modules/wolfy87-eventemitter/EventEmitter.js"(exports, module) {
    (function(exports2) {
      "use strict";
      function EventEmitter() {
      }
      var proto = EventEmitter.prototype;
      var originalGlobalValue = exports2.EventEmitter;
      function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
          if (listeners[i].listener === listener) {
            return i;
          }
        }
        return -1;
      }
      function alias(name) {
        return function aliasClosure() {
          return this[name].apply(this, arguments);
        };
      }
      proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;
        if (evt instanceof RegExp) {
          response = {};
          for (key in events) {
            if (events.hasOwnProperty(key) && evt.test(key)) {
              response[key] = events[key];
            }
          }
        } else {
          response = events[evt] || (events[evt] = []);
        }
        return response;
      };
      proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;
        for (i = 0; i < listeners.length; i += 1) {
          flatListeners.push(listeners[i].listener);
        }
        return flatListeners;
      };
      proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;
        if (listeners instanceof Array) {
          response = {};
          response[evt] = listeners;
        }
        return response || listeners;
      };
      function isValidListener(listener) {
        if (typeof listener === "function" || listener instanceof RegExp) {
          return true;
        } else if (listener && typeof listener === "object") {
          return isValidListener(listener.listener);
        } else {
          return false;
        }
      }
      proto.addListener = function addListener(evt, listener) {
        if (!isValidListener(listener)) {
          throw new TypeError("listener must be a function");
        }
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === "object";
        var key;
        for (key in listeners) {
          if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
            listeners[key].push(listenerIsWrapped ? listener : {
              listener,
              once: false
            });
          }
        }
        return this;
      };
      proto.on = alias("addListener");
      proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
          listener,
          once: true
        });
      };
      proto.once = alias("addOnceListener");
      proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
      };
      proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
          this.defineEvent(evts[i]);
        }
        return this;
      };
      proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;
        for (key in listeners) {
          if (listeners.hasOwnProperty(key)) {
            index = indexOfListener(listeners[key], listener);
            if (index !== -1) {
              listeners[key].splice(index, 1);
            }
          }
        }
        return this;
      };
      proto.off = alias("removeListener");
      proto.addListeners = function addListeners(evt, listeners) {
        return this.manipulateListeners(false, evt, listeners);
      };
      proto.removeListeners = function removeListeners(evt, listeners) {
        return this.manipulateListeners(true, evt, listeners);
      };
      proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;
        if (typeof evt === "object" && !(evt instanceof RegExp)) {
          for (i in evt) {
            if (evt.hasOwnProperty(i) && (value = evt[i])) {
              if (typeof value === "function") {
                single.call(this, i, value);
              } else {
                multiple.call(this, i, value);
              }
            }
          }
        } else {
          i = listeners.length;
          while (i--) {
            single.call(this, evt, listeners[i]);
          }
        }
        return this;
      };
      proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;
        if (type === "string") {
          delete events[evt];
        } else if (evt instanceof RegExp) {
          for (key in events) {
            if (events.hasOwnProperty(key) && evt.test(key)) {
              delete events[key];
            }
          }
        } else {
          delete this._events;
        }
        return this;
      };
      proto.removeAllListeners = alias("removeEvent");
      proto.emitEvent = function emitEvent(evt, args) {
        var listenersMap = this.getListenersAsObject(evt);
        var listeners;
        var listener;
        var i;
        var key;
        var response;
        for (key in listenersMap) {
          if (listenersMap.hasOwnProperty(key)) {
            listeners = listenersMap[key].slice(0);
            for (i = 0; i < listeners.length; i++) {
              listener = listeners[i];
              if (listener.once === true) {
                this.removeListener(evt, listener.listener);
              }
              response = listener.listener.apply(this, args || []);
              if (response === this._getOnceReturnValue()) {
                this.removeListener(evt, listener.listener);
              }
            }
          }
        }
        return this;
      };
      proto.trigger = alias("emitEvent");
      proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
      };
      proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
      };
      proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty("_onceReturnValue")) {
          return this._onceReturnValue;
        } else {
          return true;
        }
      };
      proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
      };
      EventEmitter.noConflict = function noConflict() {
        exports2.EventEmitter = originalGlobalValue;
        return EventEmitter;
      };
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter;
        });
      } else if (typeof module === "object" && module.exports) {
        module.exports = EventEmitter;
      } else {
        exports2.EventEmitter = EventEmitter;
      }
    })(typeof window !== "undefined" ? window : exports || {});
  }
});

// node_modules/meteor-sdk/src/ddp/queue.js
var require_queue = __commonJS({
  "node_modules/meteor-sdk/src/ddp/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Queue = void 0;
    var Queue = class {
      constructor(consumer) {
        this.consumer = consumer;
        this.paused = false;
        this.queue = [];
      }
      pause() {
        this.paused = true;
      }
      continue() {
        this.paused = false;
        this.process();
      }
      push(element) {
        this.queue.push(element);
        this.process();
      }
      unshift(element) {
        this.queue.unshift(element);
        this.process();
      }
      process() {
        if (!this.paused && this.queue.length !== 0) {
          const ack = this.consumer(this.queue[0]);
          if (ack) {
            this.queue.shift();
            if (!this.paused)
              this.process();
          }
        }
      }
      empty() {
        this.queue = [];
      }
    };
    exports.Queue = Queue;
    exports.default = Queue;
  }
});

// node_modules/ejson/index.js
var require_ejson = __commonJS({
  "node_modules/ejson/index.js"(exports, module) {
    (function() {
      "use strict";
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.lengthOf = exports2.keysOf = exports2.isObject = exports2.isInfOrNaN = exports2.isFunction = exports2.isArguments = exports2.hasOwn = exports2.handleError = exports2.convertMapToObject = exports2.checkError = void 0;
          function _slicedToArray(arr, i) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
          }
          function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          function _unsupportedIterableToArray(o, minLen) {
            if (!o)
              return;
            if (typeof o === "string")
              return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor)
              n = o.constructor.name;
            if (n === "Map" || n === "Set")
              return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
              return _arrayLikeToArray(o, minLen);
          }
          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length)
              len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
          function _iterableToArrayLimit(arr, i) {
            var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
            if (_i == null)
              return;
            var _arr = [];
            var _n = true;
            var _d = false;
            var _s, _e;
            try {
              for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);
                if (i && _arr.length === i)
                  break;
              }
            } catch (err) {
              _d = true;
              _e = err;
            } finally {
              try {
                if (!_n && _i["return"] != null)
                  _i["return"]();
              } finally {
                if (_d)
                  throw _e;
              }
            }
            return _arr;
          }
          function _arrayWithHoles(arr) {
            if (Array.isArray(arr))
              return arr;
          }
          function _typeof(obj) {
            "@babel/helpers - typeof";
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
              return typeof obj2;
            } : function(obj2) {
              return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof(obj);
          }
          var isFunction = function isFunction2(fn) {
            return typeof fn === "function";
          };
          exports2.isFunction = isFunction;
          var isObject = function isObject2(fn) {
            return _typeof(fn) === "object";
          };
          exports2.isObject = isObject;
          var keysOf = function keysOf2(obj) {
            return Object.keys(obj);
          };
          exports2.keysOf = keysOf;
          var lengthOf = function lengthOf2(obj) {
            return Object.keys(obj).length;
          };
          exports2.lengthOf = lengthOf;
          var hasOwn = function hasOwn2(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
          exports2.hasOwn = hasOwn;
          var convertMapToObject = function convertMapToObject2(map) {
            return Array.from(map).reduce(function(acc, _ref) {
              var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
              acc[key] = value;
              return acc;
            }, {});
          };
          exports2.convertMapToObject = convertMapToObject;
          var isArguments = function isArguments2(obj) {
            return obj != null && hasOwn(obj, "callee");
          };
          exports2.isArguments = isArguments;
          var isInfOrNaN = function isInfOrNaN2(obj) {
            return Number.isNaN(obj) || obj === Infinity || obj === -Infinity;
          };
          exports2.isInfOrNaN = isInfOrNaN;
          var checkError = {
            maxStack: function maxStack(msgError) {
              return new RegExp("Maximum call stack size exceeded", "g").test(msgError);
            }
          };
          exports2.checkError = checkError;
          var handleError = function handleError2(fn) {
            return function() {
              try {
                return fn.apply(this, arguments);
              } catch (error) {
                var isMaxStack = checkError.maxStack(error.message);
                if (isMaxStack) {
                  throw new Error("Converting circular structure to JSON");
                }
                throw error;
              }
            };
          };
          exports2.handleError = handleError;
        },
        /* 2 */
        /***/
        function(__unused_webpack_module, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.Base64 = void 0;
          var BASE_64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var BASE_64_VALS = /* @__PURE__ */ Object.create(null);
          var getChar = function getChar2(val) {
            return BASE_64_CHARS.charAt(val);
          };
          var getVal = function getVal2(ch) {
            return ch === "=" ? -1 : BASE_64_VALS[ch];
          };
          for (var i = 0; i < BASE_64_CHARS.length; i++) {
            BASE_64_VALS[getChar(i)] = i;
          }
          ;
          var encode = function encode2(array) {
            if (typeof array === "string") {
              var str = array;
              array = newBinary(str.length);
              for (var _i = 0; _i < str.length; _i++) {
                var ch = str.charCodeAt(_i);
                if (ch > 255) {
                  throw new Error("Not ascii. Base64.encode can only take ascii strings.");
                }
                array[_i] = ch;
              }
            }
            var answer = [];
            var a = null;
            var b = null;
            var c = null;
            var d = null;
            for (var _i2 = 0; _i2 < array.length; _i2++) {
              switch (_i2 % 3) {
                case 0:
                  a = array[_i2] >> 2 & 63;
                  b = (array[_i2] & 3) << 4;
                  break;
                case 1:
                  b = b | array[_i2] >> 4 & 15;
                  c = (array[_i2] & 15) << 2;
                  break;
                case 2:
                  c = c | array[_i2] >> 6 & 3;
                  d = array[_i2] & 63;
                  answer.push(getChar(a));
                  answer.push(getChar(b));
                  answer.push(getChar(c));
                  answer.push(getChar(d));
                  a = null;
                  b = null;
                  c = null;
                  d = null;
                  break;
              }
            }
            if (a != null) {
              answer.push(getChar(a));
              answer.push(getChar(b));
              if (c == null) {
                answer.push("=");
              } else {
                answer.push(getChar(c));
              }
              if (d == null) {
                answer.push("=");
              }
            }
            return answer.join("");
          };
          var newBinary = function newBinary2(len) {
            if (typeof Uint8Array === "undefined" || typeof ArrayBuffer === "undefined") {
              var ret = [];
              for (var _i3 = 0; _i3 < len; _i3++) {
                ret.push(0);
              }
              ret.$Uint8ArrayPolyfill = true;
              return ret;
            }
            return new Uint8Array(new ArrayBuffer(len));
          };
          var decode = function decode2(str) {
            var len = Math.floor(str.length * 3 / 4);
            if (str.charAt(str.length - 1) == "=") {
              len--;
              if (str.charAt(str.length - 2) == "=") {
                len--;
              }
            }
            var arr = newBinary(len);
            var one = null;
            var two = null;
            var three = null;
            var j = 0;
            for (var _i4 = 0; _i4 < str.length; _i4++) {
              var c = str.charAt(_i4);
              var v = getVal(c);
              switch (_i4 % 4) {
                case 0:
                  if (v < 0) {
                    throw new Error("invalid base64 string");
                  }
                  one = v << 2;
                  break;
                case 1:
                  if (v < 0) {
                    throw new Error("invalid base64 string");
                  }
                  one = one | v >> 4;
                  arr[j++] = one;
                  two = (v & 15) << 4;
                  break;
                case 2:
                  if (v >= 0) {
                    two = two | v >> 2;
                    arr[j++] = two;
                    three = (v & 3) << 6;
                  }
                  break;
                case 3:
                  if (v >= 0) {
                    arr[j++] = three | v;
                  }
                  break;
              }
            }
            return arr;
          };
          var Base64 = {
            encode,
            decode,
            newBinary
          };
          exports2.Base64 = Base64;
        },
        /* 3 */
        /***/
        function(module2) {
          module2.exports = {
            //
            // When fibers are not supported on you system Meteor automatically sets this
            // function to a nope function. We're going to do the same here as there are
            // small parts of the code that call this function.
            //
            _noYieldsAllowed: function _noYieldsAllowed(f) {
              return f();
            }
          };
        },
        /* 4 */
        /***/
        function(module2, exports2) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2["default"] = void 0;
          function _typeof(obj) {
            "@babel/helpers - typeof";
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
              return typeof obj2;
            } : function(obj2) {
              return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof(obj);
          }
          function quote(string) {
            return JSON.stringify(string);
          }
          var str = function str2(key, holder, singleIndent, outerIndent, canonical) {
            var value = holder[key];
            switch (_typeof(value)) {
              case "string":
                return quote(value);
              case "number":
                return isFinite(value) ? String(value) : "null";
              case "boolean":
                return String(value);
              case "object": {
                if (!value) {
                  return "null";
                }
                var innerIndent = outerIndent + singleIndent;
                var partial = [];
                var v;
                if (Array.isArray(value) || {}.hasOwnProperty.call(value, "callee")) {
                  var length = value.length;
                  for (var i = 0; i < length; i += 1) {
                    partial[i] = str2(i, value, singleIndent, innerIndent, canonical) || "null";
                  }
                  if (partial.length === 0) {
                    v = "[]";
                  } else if (innerIndent) {
                    v = "[\n" + innerIndent + partial.join(",\n" + innerIndent) + "\n" + outerIndent + "]";
                  } else {
                    v = "[" + partial.join(",") + "]";
                  }
                  return v;
                }
                var keys = Object.keys(value);
                if (canonical) {
                  keys = keys.sort();
                }
                keys.forEach(function(k) {
                  v = str2(k, value, singleIndent, innerIndent, canonical);
                  if (v) {
                    partial.push(quote(k) + (innerIndent ? ": " : ":") + v);
                  }
                });
                if (partial.length === 0) {
                  v = "{}";
                } else if (innerIndent) {
                  v = "{\n" + innerIndent + partial.join(",\n" + innerIndent) + "\n" + outerIndent + "}";
                } else {
                  v = "{" + partial.join(",") + "}";
                }
                return v;
              }
              default:
            }
          };
          var canonicalStringify = function canonicalStringify2(value, options) {
            var allOptions = Object.assign({
              indent: "",
              canonical: false
            }, options);
            if (allOptions.indent === true) {
              allOptions.indent = "  ";
            } else if (typeof allOptions.indent === "number") {
              var newIndent = "";
              for (var i = 0; i < allOptions.indent; i++) {
                newIndent += " ";
              }
              allOptions.indent = newIndent;
            }
            return str("", {
              "": value
            }, allOptions.indent, "", allOptions.canonical);
          };
          var _default = canonicalStringify;
          exports2["default"] = _default;
          module2.exports = exports2.default;
        }
        /******/
      ];
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      var __webpack_exports__ = {};
      !function() {
        var exports2 = __webpack_exports__;
        var Base64 = __webpack_require__(2)["Base64"];
        var Meteor = __webpack_require__(3);
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
        exports2.EJSON = void 0;
        var _utils = __webpack_require__(1);
        var EJSON2 = {};
        exports2.EJSON = EJSON2;
        var customTypes = /* @__PURE__ */ new Map();
        EJSON2.addType = function(name, factory) {
          if (customTypes.has(name)) {
            throw new Error("Type ".concat(name, " already present"));
          }
          customTypes.set(name, factory);
        };
        var builtinConverters = [{
          // Date
          matchJSONValue: function matchJSONValue(obj) {
            return (0, _utils.hasOwn)(obj, "$date") && (0, _utils.lengthOf)(obj) === 1;
          },
          matchObject: function matchObject(obj) {
            return obj instanceof Date;
          },
          toJSONValue: function toJSONValue(obj) {
            return {
              $date: obj.getTime()
            };
          },
          fromJSONValue: function fromJSONValue(obj) {
            return new Date(obj.$date);
          }
        }, {
          // RegExp
          matchJSONValue: function matchJSONValue(obj) {
            return (0, _utils.hasOwn)(obj, "$regexp") && (0, _utils.hasOwn)(obj, "$flags") && (0, _utils.lengthOf)(obj) === 2;
          },
          matchObject: function matchObject(obj) {
            return obj instanceof RegExp;
          },
          toJSONValue: function toJSONValue(regexp) {
            return {
              $regexp: regexp.source,
              $flags: regexp.flags
            };
          },
          fromJSONValue: function fromJSONValue(obj) {
            return new RegExp(obj.$regexp, obj.$flags.slice(0, 50).replace(/[^gimuy]/g, "").replace(/(.)(?=.*\1)/g, ""));
          }
        }, {
          // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'
          // which we match.)
          matchJSONValue: function matchJSONValue(obj) {
            return (0, _utils.hasOwn)(obj, "$InfNaN") && (0, _utils.lengthOf)(obj) === 1;
          },
          matchObject: _utils.isInfOrNaN,
          toJSONValue: function toJSONValue(obj) {
            var sign;
            if (Number.isNaN(obj)) {
              sign = 0;
            } else if (obj === Infinity) {
              sign = 1;
            } else {
              sign = -1;
            }
            return {
              $InfNaN: sign
            };
          },
          fromJSONValue: function fromJSONValue(obj) {
            return obj.$InfNaN / 0;
          }
        }, {
          // Binary
          matchJSONValue: function matchJSONValue(obj) {
            return (0, _utils.hasOwn)(obj, "$binary") && (0, _utils.lengthOf)(obj) === 1;
          },
          matchObject: function matchObject(obj) {
            return typeof Uint8Array !== "undefined" && obj instanceof Uint8Array || obj && (0, _utils.hasOwn)(obj, "$Uint8ArrayPolyfill");
          },
          toJSONValue: function toJSONValue(obj) {
            return {
              $binary: Base64.encode(obj)
            };
          },
          fromJSONValue: function fromJSONValue(obj) {
            return Base64.decode(obj.$binary);
          }
        }, {
          // Escaping one level
          matchJSONValue: function matchJSONValue(obj) {
            return (0, _utils.hasOwn)(obj, "$escape") && (0, _utils.lengthOf)(obj) === 1;
          },
          matchObject: function matchObject(obj) {
            var match = false;
            if (obj) {
              var keyCount = (0, _utils.lengthOf)(obj);
              if (keyCount === 1 || keyCount === 2) {
                match = builtinConverters.some(function(converter) {
                  return converter.matchJSONValue(obj);
                });
              }
            }
            return match;
          },
          toJSONValue: function toJSONValue(obj) {
            var newObj = {};
            (0, _utils.keysOf)(obj).forEach(function(key) {
              newObj[key] = EJSON2.toJSONValue(obj[key]);
            });
            return {
              $escape: newObj
            };
          },
          fromJSONValue: function fromJSONValue(obj) {
            var newObj = {};
            (0, _utils.keysOf)(obj.$escape).forEach(function(key) {
              newObj[key] = EJSON2.fromJSONValue(obj.$escape[key]);
            });
            return newObj;
          }
        }, {
          // Custom
          matchJSONValue: function matchJSONValue(obj) {
            return (0, _utils.hasOwn)(obj, "$type") && (0, _utils.hasOwn)(obj, "$value") && (0, _utils.lengthOf)(obj) === 2;
          },
          matchObject: function matchObject(obj) {
            return EJSON2._isCustomType(obj);
          },
          toJSONValue: function toJSONValue(obj) {
            var jsonValue = Meteor._noYieldsAllowed(function() {
              return obj.toJSONValue();
            });
            return {
              $type: obj.typeName(),
              $value: jsonValue
            };
          },
          fromJSONValue: function fromJSONValue(obj) {
            var typeName = obj.$type;
            if (!customTypes.has(typeName)) {
              throw new Error("Custom EJSON type ".concat(typeName, " is not defined"));
            }
            var converter = customTypes.get(typeName);
            return Meteor._noYieldsAllowed(function() {
              return converter(obj.$value);
            });
          }
        }];
        EJSON2._isCustomType = function(obj) {
          return obj && (0, _utils.isFunction)(obj.toJSONValue) && (0, _utils.isFunction)(obj.typeName) && customTypes.has(obj.typeName());
        };
        EJSON2._getTypes = function() {
          var isOriginal = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          return isOriginal ? customTypes : (0, _utils.convertMapToObject)(customTypes);
        };
        EJSON2._getConverters = function() {
          return builtinConverters;
        };
        var toJSONValueHelper = function toJSONValueHelper2(item) {
          for (var i = 0; i < builtinConverters.length; i++) {
            var converter = builtinConverters[i];
            if (converter.matchObject(item)) {
              return converter.toJSONValue(item);
            }
          }
          return void 0;
        };
        var adjustTypesToJSONValue = function adjustTypesToJSONValue2(obj) {
          if (obj === null) {
            return null;
          }
          var maybeChanged = toJSONValueHelper(obj);
          if (maybeChanged !== void 0) {
            return maybeChanged;
          }
          if (!(0, _utils.isObject)(obj)) {
            return obj;
          }
          (0, _utils.keysOf)(obj).forEach(function(key) {
            var value = obj[key];
            if (!(0, _utils.isObject)(value) && value !== void 0 && !(0, _utils.isInfOrNaN)(value)) {
              return;
            }
            var changed = toJSONValueHelper(value);
            if (changed) {
              obj[key] = changed;
              return;
            }
            adjustTypesToJSONValue2(value);
          });
          return obj;
        };
        EJSON2._adjustTypesToJSONValue = adjustTypesToJSONValue;
        EJSON2.toJSONValue = function(item) {
          var changed = toJSONValueHelper(item);
          if (changed !== void 0) {
            return changed;
          }
          var newItem = item;
          if ((0, _utils.isObject)(item)) {
            newItem = EJSON2.clone(item);
            adjustTypesToJSONValue(newItem);
          }
          return newItem;
        };
        var fromJSONValueHelper = function fromJSONValueHelper2(value) {
          if ((0, _utils.isObject)(value) && value !== null) {
            var keys = (0, _utils.keysOf)(value);
            if (keys.length <= 2 && keys.every(function(k) {
              return typeof k === "string" && k.substr(0, 1) === "$";
            })) {
              for (var i = 0; i < builtinConverters.length; i++) {
                var converter = builtinConverters[i];
                if (converter.matchJSONValue(value)) {
                  return converter.fromJSONValue(value);
                }
              }
            }
          }
          return value;
        };
        var adjustTypesFromJSONValue = function adjustTypesFromJSONValue2(obj) {
          if (obj === null) {
            return null;
          }
          var maybeChanged = fromJSONValueHelper(obj);
          if (maybeChanged !== obj) {
            return maybeChanged;
          }
          if (!(0, _utils.isObject)(obj)) {
            return obj;
          }
          (0, _utils.keysOf)(obj).forEach(function(key) {
            var value = obj[key];
            if ((0, _utils.isObject)(value)) {
              var changed = fromJSONValueHelper(value);
              if (value !== changed) {
                obj[key] = changed;
                return;
              }
              adjustTypesFromJSONValue2(value);
            }
          });
          return obj;
        };
        EJSON2._adjustTypesFromJSONValue = adjustTypesFromJSONValue;
        EJSON2.fromJSONValue = function(item) {
          var changed = fromJSONValueHelper(item);
          if (changed === item && (0, _utils.isObject)(item)) {
            changed = EJSON2.clone(item);
            adjustTypesFromJSONValue(changed);
          }
          return changed;
        };
        EJSON2.stringify = (0, _utils.handleError)(function(item, options) {
          var serialized;
          var json = EJSON2.toJSONValue(item);
          if (options && (options.canonical || options.indent)) {
            var canonicalStringify = __webpack_require__(4);
            serialized = canonicalStringify(json, options);
          } else {
            serialized = JSON.stringify(json);
          }
          return serialized;
        });
        EJSON2.parse = function(item) {
          if (typeof item !== "string") {
            throw new Error("EJSON.parse argument should be a string");
          }
          return EJSON2.fromJSONValue(JSON.parse(item));
        };
        EJSON2.isBinary = function(obj) {
          return !!(typeof Uint8Array !== "undefined" && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill);
        };
        EJSON2.equals = function(a, b, options) {
          var i;
          var keyOrderSensitive = !!(options && options.keyOrderSensitive);
          if (a === b) {
            return true;
          }
          if (Number.isNaN(a) && Number.isNaN(b)) {
            return true;
          }
          if (!a || !b) {
            return false;
          }
          if (!((0, _utils.isObject)(a) && (0, _utils.isObject)(b))) {
            return false;
          }
          if (a instanceof Date && b instanceof Date) {
            return a.valueOf() === b.valueOf();
          }
          if (EJSON2.isBinary(a) && EJSON2.isBinary(b)) {
            if (a.length !== b.length) {
              return false;
            }
            for (i = 0; i < a.length; i++) {
              if (a[i] !== b[i]) {
                return false;
              }
            }
            return true;
          }
          if ((0, _utils.isFunction)(a.equals)) {
            return a.equals(b, options);
          }
          if ((0, _utils.isFunction)(b.equals)) {
            return b.equals(a, options);
          }
          var aIsArray = Array.isArray(a);
          var bIsArray = Array.isArray(b);
          if (aIsArray !== bIsArray) {
            return false;
          }
          if (aIsArray && bIsArray) {
            if (a.length !== b.length) {
              return false;
            }
            for (i = 0; i < a.length; i++) {
              if (!EJSON2.equals(a[i], b[i], options)) {
                return false;
              }
            }
            return true;
          }
          switch (EJSON2._isCustomType(a) + EJSON2._isCustomType(b)) {
            case 1:
              return false;
            case 2:
              return EJSON2.equals(EJSON2.toJSONValue(a), EJSON2.toJSONValue(b));
            default:
          }
          var ret;
          var aKeys = (0, _utils.keysOf)(a);
          var bKeys = (0, _utils.keysOf)(b);
          if (keyOrderSensitive) {
            i = 0;
            ret = aKeys.every(function(key) {
              if (i >= bKeys.length) {
                return false;
              }
              if (key !== bKeys[i]) {
                return false;
              }
              if (!EJSON2.equals(a[key], b[bKeys[i]], options)) {
                return false;
              }
              i++;
              return true;
            });
          } else {
            i = 0;
            ret = aKeys.every(function(key) {
              if (!(0, _utils.hasOwn)(b, key)) {
                return false;
              }
              if (!EJSON2.equals(a[key], b[key], options)) {
                return false;
              }
              i++;
              return true;
            });
          }
          return ret && i === bKeys.length;
        };
        EJSON2.clone = function(v) {
          var ret;
          if (!(0, _utils.isObject)(v)) {
            return v;
          }
          if (v === null) {
            return null;
          }
          if (v instanceof Date) {
            return new Date(v.getTime());
          }
          if (v instanceof RegExp) {
            return v;
          }
          if (EJSON2.isBinary(v)) {
            ret = EJSON2.newBinary(v.length);
            for (var i = 0; i < v.length; i++) {
              ret[i] = v[i];
            }
            return ret;
          }
          if (Array.isArray(v)) {
            return v.map(EJSON2.clone);
          }
          if ((0, _utils.isArguments)(v)) {
            return Array.from(v).map(EJSON2.clone);
          }
          if ((0, _utils.isFunction)(v.clone)) {
            return v.clone();
          }
          if (EJSON2._isCustomType(v)) {
            return EJSON2.fromJSONValue(EJSON2.clone(EJSON2.toJSONValue(v)), true);
          }
          ret = {};
          (0, _utils.keysOf)(v).forEach(function(key) {
            ret[key] = EJSON2.clone(v[key]);
          });
          return ret;
        };
        EJSON2.newBinary = Base64.newBinary;
      }();
      module.exports = __webpack_exports__.EJSON;
    })();
  }
});

// node_modules/meteor-sdk/src/ddp/utils.js
var require_utils = __commonJS({
  "node_modules/meteor-sdk/src/ddp/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.run = exports.generateId = void 0;
    var id = 0;
    function generateId() {
      return (id++).toString();
    }
    exports.generateId = generateId;
    function run(runnable) {
      try {
        const r = runnable();
        return [r, null];
      } catch (e) {
        return [null, e];
      }
    }
    exports.run = run;
  }
});

// node_modules/meteor-sdk/src/ddp/socket.js
var require_socket = __commonJS({
  "node_modules/meteor-sdk/src/ddp/socket.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var wolfy87_eventemitter_1 = __importDefault(require_EventEmitter());
    var ejson_1 = __importDefault(require_ejson());
    var utils_1 = require_utils();
    var Socket = class extends wolfy87_eventemitter_1.default {
      constructor(SocketConstructor, endpoint) {
        super();
        this.SocketConstructor = SocketConstructor;
        this.endpoint = endpoint;
        this.rawSocket = null;
      }
      send(object) {
        const message = ejson_1.default.stringify(object);
        this.rawSocket.send(message);
        this.emit("message:out", ejson_1.default.parse(message));
      }
      open() {
        if (this.rawSocket) {
          return;
        }
        this.rawSocket = new this.SocketConstructor(this.endpoint);
        this.rawSocket.onopen = () => this.emit("open");
        this.rawSocket.onclose = () => {
          this.rawSocket = null;
          this.emit("close");
        };
        this.rawSocket.onerror = () => {
          if (this.rawSocket && this.rawSocket.onclose) {
            delete this.rawSocket.onclose;
          }
          this.rawSocket.close();
          this.rawSocket = null;
          this.emit("close");
        };
        this.rawSocket.onmessage = (message) => {
          const [object, error] = (0, utils_1.run)(() => ejson_1.default.parse(message.data));
          if (error) {
            return;
          }
          this.emit("message:in", object);
        };
      }
      close() {
        if (this.rawSocket) {
          this.rawSocket.close();
        }
      }
    };
    exports.default = Socket;
  }
});

// node_modules/meteor-sdk/src/ddp/ddp.js
var require_ddp = __commonJS({
  "node_modules/meteor-sdk/src/ddp/ddp.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var wolfy87_eventemitter_1 = __importDefault(require_EventEmitter());
    var queue_1 = __importDefault(require_queue());
    var socket_1 = __importDefault(require_socket());
    var utils_1 = require_utils();
    var DDP_VERSION = "1";
    var PUBLIC_EVENTS = [
      // Subscription messages
      "ready",
      "nosub",
      "added",
      "changed",
      "removed",
      // Method messages
      "result",
      "updated",
      // Error messages
      "error"
    ];
    var DEFAULT_RECONNECT_INTERVAL = 1e4;
    var DDP2 = class extends wolfy87_eventemitter_1.default {
      constructor(options) {
        super();
        this.cleanQueue = false;
        this.autoConnect = false;
        this.status = "disconnected";
        this.sessionId = null;
        this.cleanQueue = options.cleanQueue || false;
        this.autoConnect = options.autoConnect !== false;
        this.autoReconnect = options.autoReconnect !== false;
        this.autoReconnectUserValue = this.autoReconnect;
        this.reconnectInterval = options.reconnectInterval || DEFAULT_RECONNECT_INTERVAL;
        this.messageQueue = new queue_1.default((message) => {
          if (this.status === "connected") {
            this.socket.send(message);
            return true;
          } else {
            return false;
          }
        });
        this.socket = new socket_1.default(options.SocketConstructor, options.endpoint);
        this.socket.on("open", () => {
          let params = {
            msg: "connect",
            version: DDP_VERSION,
            support: [DDP_VERSION],
            session: void 0
          };
          if (this.sessionId)
            params.session = this.sessionId;
          this.socket.send(params);
        });
        this.socket.on("close", () => {
          let oldStatus = this.status;
          this.status = "disconnected";
          if (this.cleanQueue)
            this.messageQueue.empty();
          if (oldStatus != "disconnected")
            this.emit("disconnected");
          if (this.autoReconnect) {
            setTimeout(this.socket.open.bind(this.socket), this.reconnectInterval);
          }
        });
        this.socket.on("message:in", (message) => {
          if (message.msg === "connected") {
            this.status = "connected";
            this.sessionId = message.session ? message.session : null;
            this.messageQueue.process();
            this.emit("connected", message);
          } else if (message.msg === "ping") {
            this.socket.send({ msg: "pong", id: message.id });
          } else if (PUBLIC_EVENTS.includes(message.msg)) {
            this.emit(message.msg, message);
          }
        });
        if (this.autoConnect) {
          this.connect();
        }
      }
      // @ts-ignore
      emit(event, ...args) {
        if (args === void 0)
          setTimeout(super.emit.bind(this, event), 0);
        else
          setTimeout(super.emit.bind(this, event, ...args), 0);
      }
      connect() {
        this.autoReconnect = this.autoReconnectUserValue;
        this.socket.open();
      }
      disconnect() {
        this.autoReconnectUserValue = this.autoReconnect;
        this.autoReconnect = false;
        this.sessionId = null;
        this.socket.close();
      }
      pauseQueue() {
        this.messageQueue.pause();
      }
      continueQueue() {
        this.messageQueue.continue();
      }
      method(name, params, atBeginning = false) {
        const id = (0, utils_1.generateId)();
        this.messageQueue[atBeginning ? "unshift" : "push"]({
          msg: "method",
          id,
          method: name,
          params
        });
        return id;
      }
      sub(name, params, id = (0, utils_1.generateId)()) {
        this.messageQueue.push({
          msg: "sub",
          id,
          name,
          params
        });
        return id;
      }
      unsub(id) {
        this.messageQueue.push({
          msg: "unsub",
          id
        });
        return id;
      }
    };
    exports.default = DDP2;
  }
});

// node_modules/meteor-sdk/src/helpers/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/meteor-sdk/src/helpers/isEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEqual = void 0;
    var isEqual2 = (value, other) => {
      const type = Object.prototype.toString.call(value);
      if (type !== Object.prototype.toString.call(other))
        return false;
      if (["[object Array]", "[object Object]"].indexOf(type) < 0)
        return false;
      const valueLen = Array.isArray(value) ? value.length : Object.keys(value).length;
      const otherLen = Array.isArray(other) ? other.length : Object.keys(other).length;
      if (valueLen !== otherLen)
        return false;
      const compare = (item1, item2) => {
        const itemType = Object.prototype.toString.call(item1);
        if (["[object Array]", "[object Object]"].indexOf(itemType) >= 0) {
          if (!(0, exports.isEqual)(item1, item2))
            return false;
        } else {
          if (itemType !== Object.prototype.toString.call(item2))
            return false;
          if (itemType === "[object Function]") {
            if (item1.toString() !== item2.toString())
              return false;
          } else {
            if (item1 !== item2)
              return false;
          }
        }
      };
      if (Array.isArray(value) && Array.isArray(other)) {
        for (let i = 0; i < valueLen; i++) {
          if (!compare(value[i], other[i]))
            return false;
        }
      } else {
        for (const key in value) {
          if (value.hasOwnProperty(key) && other.hasOwnProperty(key)) {
            const k = key;
            if (!compare(value[key], other[k]))
              return false;
          }
        }
      }
      return true;
    };
    exports.isEqual = isEqual2;
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports, module) {
    var toString = Object.prototype.toString;
    module.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/shallow-clone/index.js
var require_shallow_clone = __commonJS({
  "node_modules/shallow-clone/index.js"(exports, module) {
    "use strict";
    var valueOf = Symbol.prototype.valueOf;
    var typeOf = require_kind_of();
    function clone(val, deep) {
      switch (typeOf(val)) {
        case "array":
          return val.slice();
        case "object":
          return Object.assign({}, val);
        case "date":
          return new val.constructor(Number(val));
        case "map":
          return new Map(val);
        case "set":
          return new Set(val);
        case "buffer":
          return cloneBuffer(val);
        case "symbol":
          return cloneSymbol(val);
        case "arraybuffer":
          return cloneArrayBuffer(val);
        case "float32array":
        case "float64array":
        case "int16array":
        case "int32array":
        case "int8array":
        case "uint16array":
        case "uint32array":
        case "uint8clampedarray":
        case "uint8array":
          return cloneTypedArray(val);
        case "regexp":
          return cloneRegExp(val);
        case "error":
          return Object.create(val);
        default: {
          return val;
        }
      }
    }
    function cloneRegExp(val) {
      const flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
      const re = new val.constructor(val.source, flags);
      re.lastIndex = val.lastIndex;
      return re;
    }
    function cloneArrayBuffer(val) {
      const res = new val.constructor(val.byteLength);
      new Uint8Array(res).set(new Uint8Array(val));
      return res;
    }
    function cloneTypedArray(val, deep) {
      return new val.constructor(val.buffer, val.byteOffset, val.length);
    }
    function cloneBuffer(val) {
      const len = val.length;
      const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
      val.copy(buf);
      return buf;
    }
    function cloneSymbol(val) {
      return valueOf ? Object(valueOf.call(val)) : {};
    }
    module.exports = clone;
  }
});

// node_modules/isobject/index.js
var require_isobject = __commonJS({
  "node_modules/isobject/index.js"(exports, module) {
    "use strict";
    module.exports = function isObject(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "node_modules/is-plain-object/index.js"(exports, module) {
    "use strict";
    var isObject = require_isobject();
    function isObjectObject(o) {
      return isObject(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/clone-deep/index.js
var require_clone_deep = __commonJS({
  "node_modules/clone-deep/index.js"(exports, module) {
    "use strict";
    var clone = require_shallow_clone();
    var typeOf = require_kind_of();
    var isPlainObject = require_is_plain_object();
    function cloneDeep(val, instanceClone) {
      switch (typeOf(val)) {
        case "object":
          return cloneObjectDeep(val, instanceClone);
        case "array":
          return cloneArrayDeep(val, instanceClone);
        default: {
          return clone(val);
        }
      }
    }
    function cloneObjectDeep(val, instanceClone) {
      if (typeof instanceClone === "function") {
        return instanceClone(val);
      }
      if (instanceClone || isPlainObject(val)) {
        const res = new val.constructor();
        for (let key in val) {
          res[key] = cloneDeep(val[key], instanceClone);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val, instanceClone) {
      const res = new val.constructor(val.length);
      for (let i = 0; i < val.length; i++) {
        res[i] = cloneDeep(val[i], instanceClone);
      }
      return res;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/meteor-sdk/src/helpers/fullCopy.js
var require_fullCopy = __commonJS({
  "node_modules/meteor-sdk/src/helpers/fullCopy.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fullCopy = void 0;
    var clone_deep_1 = __importDefault(require_clone_deep());
    exports.fullCopy = clone_deep_1.default;
  }
});

// node_modules/meteor-sdk/src/classes/ddpEventListener.js
var require_ddpEventListener = __commonJS({
  "node_modules/meteor-sdk/src/classes/ddpEventListener.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddpEventListener = void 0;
    function ddpEventListener2(eventname, f, ddplink) {
      let _started = false;
      const start = () => {
        if (!_started) {
          ddplink.ddpConnection.on(eventname, f);
          _started = true;
        }
      };
      const stop = () => {
        if (_started) {
          ddplink.ddpConnection.removeListener(eventname, f);
          _started = false;
        }
      };
      start();
      return { start, stop };
    }
    exports.ddpEventListener = ddpEventListener2;
  }
});

// node_modules/meteor-sdk/src/classes/ddpSubscription.js
var require_ddpSubscription = __commonJS({
  "node_modules/meteor-sdk/src/classes/ddpSubscription.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddpSubscription = void 0;
    var ddpSubscription2 = class {
      constructor(pubname, args, ddplink) {
        this._nosub = false;
        this._started = false;
        this._ready = false;
        this.selfReadyEvent = {
          start: () => {
          },
          stop: () => {
          }
        };
        this.selfNosubEvent = {
          start: () => {
          },
          stop: () => {
          }
        };
        this._ddplink = ddplink;
        this.pubname = pubname;
        this.args = args;
        this.selfReadyEvent = ddplink.on("ready", (m) => {
          if (m.subs.includes(this.subscriptionId)) {
            this._ready = true;
            this._nosub = false;
          }
        });
        this.selfNosubEvent = ddplink.on("nosub", (m) => {
          if (m.id == this.subscriptionId) {
            this._ready = false;
            this._nosub = true;
            this._started = false;
          }
        });
        this.start();
      }
      /**
       * Runs everytime when `nosub` message corresponding to the subscription comes from the server.
       * @public
       * @param {Function} f - Function, event handler.
       * @return {ddpEventListener}
       */
      onNosub(f) {
        if (this.isStopped()) {
          f();
        } else {
          return this._ddplink.on("nosub", (m) => {
            if (m.id == this.subscriptionId) {
              f(m.error || m);
            }
          });
        }
      }
      /**
       * Runs everytime when `ready` message corresponding to the subscription comes from the server.
       * @public
       * @param {Function} f - Function, event handler.
       * @return {ddpEventListener}
       */
      onReady(f) {
        if (this.isReady()) {
          f();
        } else {
          return this._ddplink.on("ready", (m) => {
            if (m.subs.includes(this.subscriptionId)) {
              f();
            }
          });
        }
      }
      /**
       * Returns true if subsciprtion is ready otherwise false.
       * @public
       * @return {boolean}
       */
      isReady() {
        return this._ready;
      }
      /**
       * Returns true if subscription is stopped otherwise false.
       * @public
       * @return {boolean}
       */
      isStopped() {
        return this._nosub;
      }
      /**
       * Returns a promise which resolves when subscription is ready or rejects when `nosub` message arrives.
       * @public
       * @return {Promise}
       */
      ready() {
        return new Promise((resolve, reject) => {
          if (this.isReady()) {
            resolve();
          } else {
            let onReady = this._ddplink.on("ready", (m) => {
              if (m.subs.includes(this.subscriptionId)) {
                onReady.stop();
                onNosub.stop();
                resolve();
              }
            });
            let onNosub = this._ddplink.on("nosub", (m) => {
              if (m.id == this.subscriptionId) {
                onNosub.stop();
                onReady.stop();
                reject(m.error || m);
              }
            });
          }
        });
      }
      /**
       * Returns a promise which resolves when corresponding `nosub` message arrives.
       * Rejects when `nosub` comes with error.
       * @public
       * @return {Promise}
       */
      nosub() {
        return new Promise((resolve, reject) => {
          if (this.isStopped()) {
            resolve();
          } else {
            let onNosub = this._ddplink.on("nosub", (m) => {
              if (m.id == this.subscriptionId) {
                this._nosub = true;
                onNosub.stop();
                if (m.error) {
                  reject(m.error);
                } else {
                  resolve();
                }
              }
            });
          }
        });
      }
      /**
       * Returns true if subscription is active otherwise false.
       * @public
       * @return {Promise}
       */
      isOn() {
        return this._started;
      }
      /**
       * Completly removes subscription.
       * @public
       */
      remove() {
        this.selfNosubEvent.stop();
        this.stop();
        let i = this._ddplink.subs.indexOf(this);
        if (i > -1) {
          this._ddplink.subs.splice(i, 1);
        }
      }
      /**
       * Stops subscription and return a promise which resolves when subscription is stopped.
       * @public
       * @return {Promise}
       */
      stop() {
        if (this._started) {
          this.selfReadyEvent.stop();
          if (!this._nosub)
            this._ddplink.ddpConnection.unsub(this.subscriptionId);
          this._started = false;
          this._ready = false;
        }
        return this.nosub();
      }
      /**
       * Returns subscription id.
       * @private
       * @return {Promise}
       */
      _getId() {
        return this.subscriptionId;
      }
      /**
       * Start the subscription. Runs on class creation.
       * Returns a promise which resolves when subscription is ready.
       * @public
       * @param {Array} args - Subscription arguments.
       * @return {Promise}
       */
      start(args) {
        if (!this._started) {
          this.selfReadyEvent.start();
          if (Array.isArray(args))
            this.args = args;
          this.subscriptionId = this._ddplink.ddpConnection.sub(this.pubname, this.args);
          this._started = true;
        }
        return this.ready();
      }
      /**
       * Restart the subscription. You can also change subscription arguments.
       * Returns a promise which resolves when subscription is ready.
       * @public
       * @param {Array} [args] - Subscription arguments.
       * @return {Promise}
       */
      restart(args) {
        return new Promise((resolve, reject) => {
          this.stop().then(() => {
            this.start(args).then(() => {
              resolve();
            }).catch((e) => {
              reject(e);
            });
          }).catch((e) => {
            reject(e);
          });
        });
      }
    };
    exports.ddpSubscription = ddpSubscription2;
  }
});

// node_modules/meteor-sdk/src/classes/ddpOnChange.js
var require_ddpOnChange = __commonJS({
  "node_modules/meteor-sdk/src/classes/ddpOnChange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddpOnChange = void 0;
    function ddpOnChange(obj, inst, listenersArray = "onChangeFuncs") {
      let _isStopped = true;
      const start = () => {
        if (_isStopped) {
          inst[listenersArray].push(obj);
          _isStopped = false;
        }
      };
      const stop = () => {
        const index = inst[listenersArray].indexOf(obj);
        if (index > -1) {
          inst[listenersArray].splice(index, 1);
          _isStopped = true;
        }
      };
      start();
      return { start, stop };
    }
    exports.ddpOnChange = ddpOnChange;
  }
});

// node_modules/meteor-sdk/src/classes/ddpReducer.js
var require_ddpReducer = __commonJS({
  "node_modules/meteor-sdk/src/classes/ddpReducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddpReducer = void 0;
    var ddpOnChange_js_1 = require_ddpOnChange();
    var ddpReducer = class {
      constructor(ddpReactiveCollectionInstance, reducer, initialValue) {
        this._started = false;
        this._data = { result: null };
        this._tickers = [];
        this._ddpReactiveCollectionInstance = ddpReactiveCollectionInstance;
        this._reducer = reducer;
        this._initialValue = initialValue;
        this.start();
      }
      /**
       * Forcibly reduces reactive data.
       * @public
       */
      doReduce() {
        if (this._started) {
          this._data.result = this._ddpReactiveCollectionInstance.data().reduce(this._reducer, this._initialValue);
          this._tickers.forEach((ticker) => {
            ticker(this.data().result);
          });
        }
      }
      /**
       * Starts reactiveness for the reduced value of the collection.
       * This method is being called on instance creation.
       * @public
       */
      start() {
        if (!this._started) {
          this.doReduce();
          this._ddpReactiveCollectionInstance._activateReducer(this);
          this._started = true;
        }
      }
      /**
       * Stops reactiveness.
       * @public
       */
      stop() {
        if (this._started) {
          this._ddpReactiveCollectionInstance._deactivateReducer(this);
          this._started = false;
        }
      }
      /**
       * Returns reactive reduce.
       * @public
       * @return {Object} - {result:reducedValue}
       */
      data() {
        return this._data;
      }
      /**
       * Runs a function every time a change occurs.
       * @param {Function} f - Function which recieves a reduced value at each change.
       * @public
       */
      onChange(f) {
        const self = this;
        return (0, ddpOnChange_js_1.ddpOnChange)(f, self, "_tickers");
      }
    };
    exports.ddpReducer = ddpReducer;
  }
});

// node_modules/meteor-sdk/src/classes/ddpReactiveDocument.js
var require_ddpReactiveDocument = __commonJS({
  "node_modules/meteor-sdk/src/classes/ddpReactiveDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddpReactiveDocument = void 0;
    var ddpOnChange_js_1 = require_ddpOnChange();
    var ddpReactiveDocument = class {
      constructor(ddpReactiveCollectionInstance, settings) {
        this._ddpReactiveCollectionInstance = ddpReactiveCollectionInstance;
        this._started = false;
        this._data = {};
        this._tickers = [];
        this._preserve = false;
        if (typeof settings === "object" && settings !== null)
          this.settings(settings);
        this.start();
      }
      /**
       * Updates reactive object from local collection copies.
       * @private
       * @param {Object} newState - Document's new state.
       */
      _update(newState) {
        if (newState) {
          Object.keys(this._data).forEach((key) => {
            delete this._data[key];
          });
          Object.assign(this._data, newState);
        } else {
          if (!this._preserve) {
            Object.keys(this._data).forEach((key) => {
              delete this._data[key];
            });
          }
        }
        this._tickers.forEach((ticker) => {
          ticker(this.data());
        });
      }
      /**
       * Starts reactiveness for the document. This method is being called on instance creation.
       * @public
       */
      start() {
        if (!this._started) {
          this._update(this._ddpReactiveCollectionInstance.data()[0]);
          this._ddpReactiveCollectionInstance._activateReactiveObject(this);
          this._started = true;
        }
      }
      /**
       * Stops reactiveness for the document.
       * @public
       */
      stop() {
        if (this._started) {
          this._ddpReactiveCollectionInstance._deactivateReactiveObject(this);
          this._started = false;
        }
      }
      /**
       * Returns reactive document.
       * @public
       * @return {Object}
       */
      data() {
        return this._data;
      }
      /**
       * Runs a function every time a change occurs.
       * @param {Function} f - Function which recieves a new value at each change.
       * @public
       */
      onChange(f) {
        const self = this;
        return (0, ddpOnChange_js_1.ddpOnChange)(f, self, "_tickers");
      }
      /**
       * Change reactivity settings.
       * @param {Object} settings
       * @param {boolean} settings.preserve - When preserve is true,reactive object won't change when corresponding object is being deleted.
       * @public
       */
      settings({ preserve }) {
        this._preserve = !!preserve;
      }
    };
    exports.ddpReactiveDocument = ddpReactiveDocument;
  }
});

// node_modules/meteor-sdk/src/classes/ddpReactiveCollection.js
var require_ddpReactiveCollection = __commonJS({
  "node_modules/meteor-sdk/src/classes/ddpReactiveCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddpReactiveCollection = void 0;
    var ddpReducer_js_1 = require_ddpReducer();
    var ddpReactiveDocument_js_1 = require_ddpReactiveDocument();
    var ddpOnChange_js_1 = require_ddpOnChange();
    var ddpReactiveCollection = class {
      constructor(ddpCollectionInstance, settings, filter) {
        this._length = { result: 0 };
        this._data = [];
        this._rawData = [];
        this._reducers = [];
        this._tickers = [];
        this._ones = [];
        this._first = {};
        this._skip = settings && typeof settings.skip === "number" ? settings.skip : 0;
        this._limit = settings && typeof settings.limit === "number" ? settings.limit : Infinity;
        this._sort = settings && typeof settings.sort === "function" ? settings.sort : false;
        this._syncFunc = function(skip, limit, sort) {
          const options = {};
          if (typeof skip === "number")
            options.skip = skip;
          if (typeof limit === "number")
            options.limit = limit;
          if (sort) {
            options.sort = sort;
          }
          return ddpCollectionInstance.fetch.call(ddpCollectionInstance, options);
        };
        this._changeHandler = ddpCollectionInstance.onChange(({ prev, next, predicatePassed }) => {
          if (prev && next) {
            if (predicatePassed[0] == 0 && predicatePassed[1] == 1) {
              this._smartUpdate(next);
            } else if (predicatePassed[0] == 1 && predicatePassed[1] == 0) {
              let i = this._rawData.findIndex((obj) => {
                return obj._id == prev._id;
              });
              this._removeItem(i);
            } else if (predicatePassed[0] == 1 && predicatePassed[1] == 1) {
              let i = this._rawData.findIndex((obj) => {
                return obj._id == prev._id;
              });
              this._smartUpdate(next, i);
            }
          } else if (!prev && next) {
            this._smartUpdate(next);
          } else if (prev && !next) {
            let i = this._rawData.findIndex((obj) => {
              return obj._id == prev._id;
            });
            this._removeItem(i);
          }
          this._length.result = this._data.length;
          this._reducers.forEach((reducer) => {
            reducer.doReduce();
          });
          if (this._data[0] !== this._first) {
            this._updateReactiveObjects();
          }
          this._first = this._data[0];
          this._tickers.forEach((ticker) => {
            ticker(this.data());
          });
        }, filter ? filter : (_) => 1);
        this.started = false;
        this.start();
      }
      /**
       * Removes document from the local collection copies.
       * @private
       * @param {number} i - Document index in this._rawData array.
       */
      _removeItem(i) {
        this._rawData.splice(i, 1);
        if (i >= this._skip && i < this._skip + this._limit) {
          this._data.splice(i - this._skip, 1);
          if (this._rawData.length >= this._skip + this._limit) {
            this._data.push(this._rawData[this._skip + this._limit - 1]);
          }
        } else if (i < this._skip) {
          this._data.shift();
          if (this._rawData.length >= this._skip + this._limit) {
            this._data.push(this._rawData[this._skip + this._limit - 1]);
          }
        }
      }
      /**
       * Adds document to local the collection this._rawData according to used sorting if specified.
       * @private
       * @param {Object} newEl - Document to be added to the local collection.
       * @param j
       * @return {boolean} - The first element in the collection was changed
       */
      _smartUpdate(newEl, j) {
        let placement;
        if (!this._rawData.length) {
          placement = this._rawData.push(newEl) - 1;
          if (placement >= this._skip && placement < this._skip + this._limit) {
            this._data.push(newEl);
          }
          return;
        }
        if (this._sort) {
          for (let i = 0; i < this._rawData.length; i++) {
            if (this._sort(newEl, this._rawData[i]) < 1) {
              placement = i;
              if (i == j) {
                this._rawData[i] = newEl;
                if (j >= this._skip && j < this._skip + this._limit) {
                  this._data[j - this._skip] = newEl;
                }
              } else {
                this._removeItem(j);
                this._rawData.splice(i, 0, newEl);
                if (i >= this._skip && i < this._skip + this._limit) {
                  this._data.splice(i - this._skip, 0, newEl);
                  this._data.splice(this._limit);
                }
              }
              break;
            }
            if (i == this._rawData.length - 1) {
              placement = this._rawData.push(newEl) - 1;
              if (placement >= this._skip && placement < this._skip + this._limit) {
                this._data.push(newEl);
              }
              break;
            }
          }
        } else {
          if (typeof j === "number") {
            placement = j;
            this._rawData[j] = newEl;
            if (j >= this._skip && j < this._skip + this._limit) {
              this._data[j - this._skip] = newEl;
            }
          } else {
            placement = this._rawData.push(newEl) - 1;
            if (placement >= this._skip && placement < this._skip + this._limit) {
              this._data.push(newEl);
            }
          }
        }
      }
      /**
       * Adds reducer.
       * @private
       * @param {ddpReducer} reducer - A ddpReducer object that needs to be updated on changes.
       */
      _activateReducer(reducer) {
        this._reducers.push(reducer);
      }
      /**
       * Adds reactive object.
       * @private
       * @param {ddpReactiveDocument} o - A ddpReactiveDocument object that needs to be updated on changes.
       */
      _activateReactiveObject(o) {
        this._ones.push(o);
      }
      /**
       * Removes reducer.
       * @private
       * @param {ddpReducer} reducer - A ddpReducer object that does not need to be updated on changes.
       */
      _deactivateReducer(reducer) {
        let i = this._reducers.indexOf(reducer);
        if (i > -1) {
          this._reducers.splice(i, 1);
        }
      }
      /**
       * Removes reactive object.
       * @private
       * @param {ddpReactiveDocument} o - A ddpReducer object that does not need to be updated on changes.
       */
      _deactivateReactiveObject(o) {
        let i = this._ones.indexOf(o);
        if (i > -1) {
          this._ones.splice(i, 1);
        }
      }
      /**
       * Sends new object state for every associated reactive object.
       * @public
       */
      _updateReactiveObjects() {
        this._ones.forEach((ro) => {
          ro._update(this.data()[0]);
        });
      }
      /**
       * Updates ddpReactiveCollection settings.
       * @public
       * @param {Object} [settings={skip:0,limit:Infinity,sort:false}] - Object for declarative reactive collection slicing.
       * @return {this}
       */
      settings(settings) {
        let skip, limit, sort;
        if (settings) {
          skip = settings.skip;
          limit = settings.limit;
          sort = settings.sort;
        }
        this._skip = skip !== void 0 ? skip : this._skip;
        this._limit = limit !== void 0 ? limit : this._limit;
        this._sort = sort !== void 0 ? sort : this._sort;
        this._data.splice(0, this._data.length, ...this._syncFunc(this._skip, this._limit, this._sort));
        this._updateReactiveObjects();
        return this;
      }
      /**
       * Updates the skip parameter only.
       * @public
       * @param {number} n - A number of documents to skip.
       * @return {this}
       */
      skip(n) {
        return this.settings({ skip: n });
      }
      /**
       * Updates the limit parameter only.
       * @public
       * @param {number} n - A number of documents to observe.
       * @return {this}
       */
      limit(n) {
        return this.settings({ limit: n });
      }
      /**
       * Stops reactivity. Also stops associated reactive objects.
       * @public
       */
      stop() {
        if (this.started) {
          this._changeHandler.stop();
          this.started = false;
        }
      }
      /**
       * Starts reactivity. This method is being called on instance creation.
       * Also starts every associated reactive object.
       * @public
       */
      start() {
        if (!this.started) {
          this._rawData.splice(0, this._rawData.length, ...this._syncFunc(0, 0, this._sort));
          this._data.splice(0, this._data.length, ...this._syncFunc(this._skip, this._limit, this._sort));
          this._updateReactiveObjects();
          this._changeHandler.start();
          this.started = true;
        }
      }
      /**
       * Sorts local collection according to specified function.
       * Specified function form {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}.
       * @public
       * @param {Function} f - A function used for sorting.
       * @return {this}
       */
      sort(f) {
        this._sort = f;
        if (this._sort) {
          this._rawData.splice(0, this._rawData.length, ...this._syncFunc(0, 0, this._sort));
          this._data.splice(0, this._data.length, ...this._syncFunc(this._skip, this._limit, this._sort));
          this._updateReactiveObjects();
        }
        return this;
      }
      /**
       * Returns reactive local collection with applied sorting, skip and limit.
       * This returned array is being mutated within this class instance.
       * @public
       * @return {Array} - Local collection with applied sorting, skip and limit.
       */
      data() {
        return this._data;
      }
      /**
       * Runs a function every time a change occurs.
       * @param {Function} f - Function which recieves new collection at each change.
       * @public
       */
      onChange(f) {
        const self = this;
        return (0, ddpOnChange_js_1.ddpOnChange)(f, self, "_tickers");
      }
      /**
       * Maps reactive local collection to another reactive array.
       * Specified function form {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map}.
       * @public
       * @param {Function} f - Function that produces an element of the new Array.
       * @return {ddpReducer} - Object that allows to get reactive mapped data @see ddpReducer.
       */
      // @ts-ignore
      map(f) {
        return new ddpReducer_js_1.ddpReducer(this, function(accumulator, el, i, a) {
          return accumulator.concat(f(el, i, a));
        }, []);
      }
      /**
       * Reduces reactive local collection.
       * Specified function form {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce}.
       * @public
       * @param {Function} f - Function to execute on each element in the array.
       * @param {*} initialValue - Value to use as the first argument to the first call of the function.
       * @return {ddpReducer} - Object that allows to get reactive object based on reduced reactive local collection @see ddpReducer.
       */
      reduce(f, initialValue) {
        return new ddpReducer_js_1.ddpReducer(this, f, initialValue);
      }
      /**
       * Reactive length of the local collection.
       * @public
       * @return {Object} - Object with reactive length of the local collection. {result}
       */
      count() {
        return this._length;
      }
      /**
       * Returns a reactive object which fields are always the same as the first object in the collection.
       * @public
       * @param {Object} [settings={preserve:false}] - Settings for reactive object. Use {preserve:true} if you want to keep object on remove.
       * @return {ddpReactiveDocument} - Object that allows to get reactive object based on reduced reactive local collection @see ddpReactiveDocument.
       */
      one(settings) {
        return new ddpReactiveDocument_js_1.ddpReactiveDocument(this, settings);
      }
    };
    exports.ddpReactiveCollection = ddpReactiveCollection;
  }
});

// node_modules/meteor-sdk/src/classes/ddpCollection.js
var require_ddpCollection = __commonJS({
  "node_modules/meteor-sdk/src/classes/ddpCollection.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ddpCollection = void 0;
    var fullCopy_js_1 = require_fullCopy();
    var ddpOnChange_js_1 = require_ddpOnChange();
    var ddpReactiveCollection_1 = require_ddpReactiveCollection();
    var ejson_1 = __importDefault(require_ejson());
    var ddpCollection2 = class {
      constructor(name, server) {
        this._filter = false;
        this._name = name;
        this._server = server;
      }
      /**
       * Allows to specify specific documents inside the collection for reactive data and fetching.
       * Important: if you change filter function it won't change for the already created reactive objects.
       * @public
       * @param {Function} f - Filter function, recieves as arguments object, index and array.
       * @return {this}
       */
      filter(f = false) {
        this._filter = f;
        return this;
      }
      /**
       * Imports data inside the collection and emits all relevant events.
       * Both string and JS object types are supported.
       * @public
       * @param {string|Object} data - EJSON string or EJSON or js object.
       */
      importData(data) {
        const c = typeof data === "string" ? ejson_1.default.parse(data) : data;
        if (c[this._name]) {
          c[this._name].forEach((doc, i, arr) => {
            if (!this._filter || this._filter && typeof this._filter === "function" && this._filter(doc, i, arr)) {
              this.ddpConnection.emit("added", {
                msg: "added",
                _id: doc._id,
                collection: this._name,
                fields: doc.fields
              });
            }
          });
        }
      }
      /**
       * Exports data from the collection.
       * @public
       * @param {string} [format='string'] - If 'string' then returns EJSON string, if 'raw' returns js object.
       * @return {string|Object}
       */
      exportData(format) {
        let collectionCopy = { [this._name]: this.fetch() };
        if (format === void 0 || format == "string") {
          return ejson_1.default.stringify(collectionCopy);
        } else if (format == "raw") {
          return collectionCopy;
        }
      }
      /**
       * Returns collection data based on filter and on passed settings. Supports skip, limit and sort.
       * Order is 'filter' then 'sort' then 'skip' then 'limit'.
       * @public
       * @param {Object} [settings={skip:0,limit:Infinity,sort:null}] - Skip and limit are numbers or Infinity,
       * sort is a standard js array sort function.
       * @return {Object}
       */
      fetch(settings) {
        let skip, limit, sort;
        if (settings) {
          skip = settings.skip;
          limit = settings.limit;
          sort = settings.sort;
        }
        let c = this._server.collections[this._name];
        let collectionCopy = c ? (0, fullCopy_js_1.fullCopy)(c) : [];
        if (this._filter)
          collectionCopy = collectionCopy.filter(this._filter);
        if (sort)
          collectionCopy.sort(sort);
        if (typeof skip === "number")
          collectionCopy.splice(0, skip);
        if (typeof limit === "number" || limit == Infinity)
          collectionCopy.splice(limit);
        return collectionCopy;
      }
      /**
       * Returns reactive collection object.
       * @see ddpReactiveCollection
       * @public
       * @param {Object} [settings={skip:0,limit:Infinity,sort:null}]
       * @return {ddpReactiveCollection}
       */
      reactive(settings) {
        return new ddpReactiveCollection_1.ddpReactiveCollection(this, settings, this._filter);
      }
      /**
       * Returns change observer.
       * @see ddpOnChange
       * @public
       * @param {Function} f
       * @param {Function} filter
       * @return {ddpOnChange}
       */
      onChange(f, filter) {
        let obj = {
          collection: this._name,
          f,
          filter
        };
        if (this._filter)
          obj.filter = this._filter;
        if (filter)
          obj.filter = filter;
        return (0, ddpOnChange_js_1.ddpOnChange)(obj, this._server);
      }
    };
    exports.ddpCollection = ddpCollection2;
  }
});

// node_modules/meteor-sdk/src/DDPClient.ts
var import_ddp = __toESM(require_ddp());
var import_ejson = __toESM(require_ejson());
var import_isEqual = __toESM(require_isEqual());
var import_fullCopy = __toESM(require_fullCopy());
var import_ddpEventListener = __toESM(require_ddpEventListener());
var import_ddpSubscription = __toESM(require_ddpSubscription());
var import_ddpCollection = __toESM(require_ddpCollection());
function uniqueIdFuncGen() {
  let idCounter = 0;
  return function() {
    return idCounter++;
  };
}
var simpleDDPcounter = uniqueIdFuncGen();
function connectPlugins(plugins, ...places) {
  if (Array.isArray(plugins)) {
    plugins.forEach((p) => {
      places.forEach((place) => {
        if (p[place]) {
          p[place].call(this);
        }
      });
    });
  }
}
var DDPClient = class {
  /**
   * @param {Object} options
   * @param {string} options.endpoint - The location of the websocket server. Its format depends on the type of socket you are using. If you are using https connection you have to use wss:// protocol.
   * @param {Function} options.SocketConstructor - The constructor function that will be used to construct the socket. Meteor (currently the only DDP server available) supports websockets and SockJS sockets. So, practically speaking, this means that on the browser you can use either the browser's native WebSocket constructor or the SockJS constructor provided by the SockJS library. On the server you can use whichever library implements the websocket protocol (e.g. faye-websocket).
   * @param {boolean} [options.autoConnect=true] - Whether to establish the connection to the server upon instantiation. When false, one can manually establish the connection with the connect method.
   * @param {boolean} [options.autoReconnect=true] - Whether to try to reconnect to the server when the socket connection closes, unless the closing was initiated by a call to the disconnect method.
   * @param {number} [options.reconnectInterval=1000] - The interval in ms between reconnection attempts.
   * @param {boolean} [options.clearDataOnReconnection=true] - Whether to clear all collections data after a reconnection. This invokes fake `removed` messages on every document.
   * @param {number} [options.maxTimeout=undefined] - Maximum wait for a response from the server to the method call. Default no maxTimeout.
   * @param {Array} [plugins] - Array of plugins.
   * @return {DDPClient} - A new simpleDDP instance.
   * @example
   * var opts = {
   *    endpoint: "ws://someserver.com/websocket",
   *    SocketConstructor: WebSocket,
   *    reconnectInterval: 5000
   * };
   * var server = new simpleDDP(opts);
   */
  constructor(opts, plugins) {
    __publicField(this, "_id", simpleDDPcounter());
    __publicField(this, "_opGenId", uniqueIdFuncGen());
    __publicField(this, "_opts");
    __publicField(this, "ddpConnection");
    __publicField(this, "subs", []);
    /**
       All collections data recieved from server.
    
       @type Object
       */
    __publicField(this, "collections", {});
    __publicField(this, "onChangeFuncs", []);
    /**
       Whether the client is connected to server.
    
       @type Boolean
       */
    __publicField(this, "connected", false);
    __publicField(this, "maxTimeout");
    __publicField(this, "clearDataOnReconnection");
    __publicField(this, "tryingToConnect");
    __publicField(this, "tryingToDisconnect", false);
    __publicField(this, "willTryToReconnect");
    __publicField(this, "connectedEvent");
    __publicField(this, "connectedEventRestartSubs");
    __publicField(this, "disconnectedEvent");
    __publicField(this, "addedEvent");
    __publicField(this, "changedEvent");
    __publicField(this, "removedEvent");
    this._opts = opts;
    this.ddpConnection = new import_ddp.default(opts);
    this.maxTimeout = opts.maxTimeout;
    this.clearDataOnReconnection = opts.clearDataOnReconnection === void 0 ? true : opts.clearDataOnReconnection;
    this.tryingToConnect = opts.autoConnect === void 0 ? true : opts.autoConnect;
    this.willTryToReconnect = opts.autoReconnect === void 0 ? true : opts.autoReconnect;
    let pluginConnector = connectPlugins.bind(this, plugins);
    pluginConnector("init", "beforeConnected");
    this.connectedEvent = this.on("connected", () => {
      this.connected = true;
      this.tryingToConnect = false;
    });
    pluginConnector("afterConnected", "beforeSubsRestart");
    this.connectedEventRestartSubs = this.on("connected", () => {
      if (this.clearDataOnReconnection) {
        this.clearData().then(() => {
          this.ddpConnection.emit("clientReady");
          this.restartSubs();
        });
      } else {
        this.ddpConnection.emit("clientReady");
        this.restartSubs();
      }
    });
    pluginConnector("afterSubsRestart", "beforeDisconnected");
    this.disconnectedEvent = this.on("disconnected", () => {
      this.connected = false;
      this.tryingToDisconnect = false;
      this.tryingToConnect = this.willTryToReconnect;
    });
    pluginConnector("afterDisconnected", "beforeAdded");
    this.addedEvent = this.on("added", (m) => this.dispatchAdded(m));
    pluginConnector("afterAdded", "beforeChanged");
    this.changedEvent = this.on("changed", (m) => this.dispatchChanged(m));
    pluginConnector("afterChanged", "beforeRemoved");
    this.removedEvent = this.on("removed", (m) => this.dispatchRemoved(m));
    pluginConnector("afterRemoved", "after");
  }
  /**
   * Restarts all subs.
   * @private
   */
  restartSubs() {
    this.subs.forEach((sub) => {
      if (sub.isOn()) {
        sub.restart();
      }
    });
  }
  /**
   * Use this for fetching the subscribed data and for reactivity inside the collection.
   * @public
   * @param {string} name - Collection name.
   * @return {ddpCollection}
   */
  collection(name) {
    return new import_ddpCollection.ddpCollection(name, this);
  }
  /**
   * Dispatcher for ddp added messages.
   * @private
   * @param {Object} m - DDP message.
   */
  dispatchAdded(m) {
    if (this.collections.hasOwnProperty(m.collection)) {
      let i2 = this.collections[m.collection].findIndex((obj) => {
        return obj._id == m.id;
      });
      if (i2 > -1) {
        this.collections[m.collection].splice(i2, 1);
      }
    }
    if (!this.collections.hasOwnProperty(m.collection))
      this.collections[m.collection] = [];
    let newObj = Object.assign({ _id: m.id }, m.fields);
    let i = this.collections[m.collection].push(newObj);
    let fields = {};
    if (m.fields) {
      Object.keys(m.fields).map((p) => {
        fields[p] = 1;
      });
    }
    this.onChangeFuncs.forEach((l) => {
      if (l.collection == m.collection) {
        let hasFilter = l.hasOwnProperty("filter");
        let newObjFullCopy = (0, import_fullCopy.fullCopy)(newObj);
        if (!hasFilter) {
          l.f({ changed: false, added: newObjFullCopy, removed: false });
        } else if (hasFilter && l.filter(newObjFullCopy, i - 1, this.collections[m.collection])) {
          l.f({ prev: false, next: newObjFullCopy, fields, fieldsChanged: newObjFullCopy, fieldsRemoved: [] });
        }
      }
    });
  }
  /**
   * Dispatcher for ddp changed messages.
   * @private
   * @param {Object} m - DDP message.
   */
  dispatchChanged(m) {
    if (!this.collections.hasOwnProperty(m.collection))
      this.collections[m.collection] = [];
    let i = this.collections[m.collection].findIndex((obj) => {
      return obj._id == m.id;
    });
    if (i > -1) {
      const t = this.collections[m.collection][i];
      let prev = (0, import_fullCopy.fullCopy)(this.collections[m.collection][i]);
      let fields = {}, fieldsChanged = {}, fieldsRemoved = [];
      if (m.fields) {
        fieldsChanged = m.fields;
        Object.keys(m.fields).map((p) => {
          fields[p] = 1;
        });
        Object.assign(this.collections[m.collection][i], m.fields);
      }
      if (m.cleared) {
        fieldsRemoved = m.cleared;
        m.cleared.forEach((fieldName) => {
          fields[fieldName] = 0;
          delete this.collections[m.collection][i][fieldName];
        });
      }
      let next = this.collections[m.collection][i];
      this.onChangeFuncs.forEach((l) => {
        if (l.collection == m.collection) {
          let hasFilter = l.hasOwnProperty("filter");
          if (!hasFilter) {
            l.f({
              // @ts-ignore
              changed: { prev, next: (0, import_fullCopy.fullCopy)(next), fields, fieldsChanged, fieldsRemoved },
              added: false,
              removed: false
            });
          } else {
            let fCopyNext = (0, import_fullCopy.fullCopy)(next);
            let prevFilter = l.filter(prev, i, this.collections[m.collection]);
            let nextFilter = l.filter(fCopyNext, i, this.collections[m.collection]);
            if (prevFilter || nextFilter) {
              l.f({
                // @ts-ignore
                prev,
                next: fCopyNext,
                fields,
                fieldsChanged,
                fieldsRemoved,
                predicatePassed: [prevFilter, nextFilter]
              });
            }
          }
        }
      });
    } else {
      this.dispatchAdded(m);
    }
  }
  /**
   * Dispatcher for ddp removed messages.
   * @private
   * @param {Object} m - DDP message.
   */
  dispatchRemoved(m) {
    if (!this.collections.hasOwnProperty(m.collection))
      this.collections[m.collection] = [];
    let i = this.collections[m.collection].findIndex((obj) => {
      return obj._id == m.id;
    });
    if (i > -1) {
      let prevProps;
      let removedObj = this.collections[m.collection].splice(i, 1)[0];
      this.onChangeFuncs.forEach((l) => {
        if (l.collection == m.collection) {
          let hasFilter = l.hasOwnProperty("filter");
          if (!hasFilter) {
            l.f({ changed: false, added: false, removed: removedObj });
          } else {
            if (l.filter(removedObj, i, this.collections[m.collection])) {
              l.f({ prev: removedObj, next: false });
            }
          }
        }
      });
    }
  }
  /**
   * Connects to the ddp server. The method is called automatically by the class constructor if the autoConnect option is set to true (default behavior).
   * @public
   * @return {Promise} - Promise which resolves when connection is established.
   */
  connect() {
    this.willTryToReconnect = this._opts.autoReconnect === void 0 ? true : this._opts.autoReconnect;
    return new Promise((resolve, reject) => {
      if (!this.tryingToConnect) {
        this.ddpConnection.connect();
        this.tryingToConnect = true;
      }
      if (!this.connected) {
        let stoppingInterval;
        const connectionHandler = this.on("connected", () => {
          clearTimeout(stoppingInterval);
          connectionHandler.stop();
          this.tryingToConnect = false;
          resolve();
        });
        if (this.maxTimeout) {
          stoppingInterval = setTimeout(() => {
            connectionHandler.stop();
            this.tryingToConnect = false;
            reject(new Error("MAX_TIMEOUT_REACHED"));
          }, this.maxTimeout);
        }
      } else {
        resolve();
      }
    });
  }
  /**
   * Disconnects from the ddp server by closing the WebSocket connection. You can listen on the disconnected event to be notified of the disconnection.
   * @public
   * @return {Promise} - Promise which resolves when connection is closed.
   */
  disconnect() {
    this.willTryToReconnect = false;
    return new Promise((resolve, reject) => {
      if (!this.tryingToDisconnect) {
        this.ddpConnection.disconnect();
        this.tryingToDisconnect = true;
      }
      if (this.connected) {
        let connectionHandler = this.on("disconnected", () => {
          connectionHandler.stop();
          this.tryingToDisconnect = false;
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
  /**
   * Calls a remote method with arguments passed in array.
   * @public
   * @param {string} method - Name of the server publication.
   * @param {Array} [arguments] - Array of parameters to pass to the remote method. Pass an empty array or don't pass anything if you do not wish to pass any parameters.
   * @param {boolean} [atBeginning=false] - If true puts method call at the beginning of the requests queue.
   * @return {Promise} - Promise object, which resolves when receives a result send by server and rejects when receives an error send by server.
   * @example
   * server.apply("method1").then(function(result) {
   *	console.log(result); //show result message in console
   *    if (result.someId) {
   *        //server sends us someId, lets call next method using this id
   *        return server.apply("method2",[result.someId]);
   *    } else {
   *        //we didn't recieve an id, lets throw an error
   *        throw "no id sent";
   *    }
   * }).then(function(result) {
   *    console.log(result); //show result message from second method
   * }).catch(function(error) {
   *    console.log(result); //show error message in console
   * });
   */
  apply(method, args, atBeginning = false) {
    return new Promise((resolve, reject) => {
      const methodId = this.ddpConnection.method(method, args ? args : [], atBeginning);
      const _self = this;
      let stoppingInterval;
      function onMethodResult(message) {
        if (message.id == methodId) {
          clearTimeout(stoppingInterval);
          if (!message.error) {
            resolve(message.result);
          } else {
            reject(message.error);
          }
          _self.ddpConnection.removeListener("result", onMethodResult);
        }
      }
      this.ddpConnection.on("result", onMethodResult);
      if (this.maxTimeout) {
        stoppingInterval = setTimeout(() => {
          this.ddpConnection.removeListener("result", onMethodResult);
          reject(new Error("MAX_TIMEOUT_REACHED"));
        }, this.maxTimeout);
      }
    });
  }
  /**
   * Calls a remote method with arguments passed after the first argument.
   * Syntactic sugar for @see apply.
   * @public
   * @param {string} method - Name of the server publication.
   * @param {...any} [args] - List of parameters to pass to the remote method. Parameters are passed as function arguments.
   * @return {Promise} - Promise object, which resolves when receives a result send by server and rejects when receives an error send by server.
   */
  call(method, ...args) {
    return this.apply(method, args);
  }
  /**
   * Tries to subscribe to a specific publication on server.
   * Starts the subscription if the same subscription exists.
   * @public
   * @param {string} pubname - Name of the publication on server.
   * @param {Array} [arguments] - Array of parameters to pass to the remote method. Pass an empty array or don't pass anything if you do not wish to pass any parameters.
   * @return {ddpSubscription} - Subscription.
   */
  sub(pubname, args) {
    const k = this.apply("foo", [123, 2]);
    let hasSuchSub = this.subs.find((sub) => {
      return sub.pubname == pubname && (0, import_isEqual.isEqual)(sub.args, Array.isArray(args) ? args : []);
    });
    if (!hasSuchSub) {
      let i = this.subs.push(new import_ddpSubscription.ddpSubscription(pubname, Array.isArray(args) ? args : [], this));
      return this.subs[i - 1];
    } else {
      if (hasSuchSub.isStopped())
        hasSuchSub.start();
      return hasSuchSub;
    }
  }
  /**
   * Tries to subscribe to a specific publication on server.
   * Syntactic sugar for @see sub.
   * @public
   * @param {string} pubname - Name of the publication on server.
   * @param {...any} [args] - List of parameters to pass to the remote method. Parameters are passed as function arguments.
   * @return {ddpSubscription} - Subscription.
   */
  subscribe(pubname, ...args) {
    return this.sub(pubname, args);
  }
  /**
   * Starts listening server for basic DDP event running f each time the message arrives.
   * @public
   * @param {string} event - Any event name from DDP specification.
   * Default suppoted events: `connected`, `disconnected`, `added`, `changed`, `removed`, `ready`, `nosub`, `error`, `ping`, `pong`.
   * @param {Function} f - Function which receives a message from a DDP server as a first argument each time server is invoking event.
   * @return {ddpEventListener}
   * @example
   * server.on('connected', () => {
   *     // you can show a success message here
   * });
   *
   * server.on('disconnected', () => {
   *     // you can show a reconnection message here
   * });
   */
  on(event, f) {
    return (0, import_ddpEventListener.ddpEventListener)(event, f, this);
  }
  /**
   * Stops all reactivity.
   */
  stopChangeListeners() {
    this.onChangeFuncs = [];
  }
  /**
   * Removes all documents like if it was removed by the server publication.
   * @public
   * @return {Promise} - Resolves when data is successfully removed.
   */
  clearData() {
    return new Promise((resolve, reject) => {
      let totalDocuments = 0;
      Object.keys(this.collections).forEach((collection) => {
        totalDocuments += Array.isArray(this.collections[collection]) ? this.collections[collection].length : 0;
      });
      if (totalDocuments === 0) {
        resolve();
      } else {
        let counter = 0;
        let uniqueId = this._id + "-" + this._opGenId();
        const listener = this.on("removed", (m, id) => {
          if (id == uniqueId) {
            counter++;
            if (counter == totalDocuments) {
              listener.stop();
              resolve();
            }
          }
        });
        Object.keys(this.collections).forEach((collection) => {
          this.collections[collection].forEach((doc) => {
            this.ddpConnection.emit("removed", {
              msg: "removed",
              id: doc.id,
              collection
            }, uniqueId);
          });
        });
      }
    });
  }
  /**
   * Imports the data like if it was published by the server.
   * @public
   * @param {Object|string} data - ESJON string or EJSON.
   * @return {Promise} - Resolves when data is successfully imported.
   */
  importData(data) {
    return new Promise((resolve, reject) => {
      let c = typeof data === "string" ? import_ejson.default.parse(data) : data;
      let totalDocuments = 0;
      Object.keys(c).forEach((collection) => {
        totalDocuments += Array.isArray(c[collection]) ? c[collection].length : 0;
      });
      let counter = 0;
      let uniqueId = this._id + "-" + this._opGenId();
      const listener = this.on("added", (m, id) => {
        if (id == uniqueId) {
          counter++;
          if (counter == totalDocuments) {
            listener.stop();
            resolve();
          }
        }
      });
      Object.keys(c).forEach((collection) => {
        c[collection].forEach((doc) => {
          let docFields = Object.assign({}, doc);
          delete docFields["id"];
          this.ddpConnection.emit("added", {
            msg: "added",
            id: doc.id,
            collection,
            fields: docFields
          }, uniqueId);
        });
      });
    });
  }
  /**
   * Exports the data
   * @public
   * @param {string} [format='string'] - Possible values are 'string' (EJSON string) and 'raw' (EJSON).
   * @return {Object|string} - EJSON string or EJSON.
   */
  exportData(format) {
    if (format === void 0 || format == "string") {
      return import_ejson.default.stringify(this.collections);
    } else if (format == "raw") {
      return (0, import_fullCopy.fullCopy)(this.collections);
    }
  }
  /**
   * Marks every passed @see ddpSubscription object as ready like if it was done by the server publication.
   * @public
   * @param {Array} subs - Array of @see ddpSubscription objects.
   * @return {Promise} - Resolves when all passed subscriptions are marked as ready.
   */
  markAsReady(subs) {
    return new Promise((resolve, reject) => {
      let uniqueId = this._id + "-" + this._opGenId();
      this.ddpConnection.emit("ready", {
        msg: "ready",
        subs: subs.map((sub) => sub._getId())
      }, uniqueId);
      const listener = this.on("ready", (m, id) => {
        if (id == uniqueId) {
          listener.stop();
          resolve();
        }
      });
    });
  }
};
var DDPClient_default = DDPClient;
export {
  DDPClient_default as default
};
/*! Bundled license information:

wolfy87-eventemitter/EventEmitter.js:
  (*!
   * EventEmitter v5.2.9 - git.io/ee
   * Unlicense - http://unlicense.org/
   * Oliver Caldwell - https://oli.me.uk/
   * @preserve
   *)

shallow-clone/index.js:
  (*!
   * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=meteor-sdk.js.map
