import { c as chokidar } from '../shared/nuxi.46857576.mjs';
import { d as defineCommand, c as consola } from '../shared/nuxi.57fa43de.mjs';
import 'node:util';
import 'node:path';
import 'node:process';
import 'node:tty';
import { w as writeTypes } from '../shared/nuxi.3b5e40b8.mjs';
import { l as loadKit } from '../shared/nuxi.f65c0f6b.mjs';
import { o as overrideEnv } from '../shared/nuxi.2509f57e.mjs';
import { l as loadNuxtManifest, w as writeNuxtManifest } from '../shared/nuxi.2c92dc7e.mjs';
import { a as clearBuildDir } from '../shared/nuxi.e016df24.mjs';
import { s as sharedArgs, l as legacyRootDirArgs } from '../shared/nuxi.01862219.mjs';
import { Server } from 'http';
import { t as toNodeListener } from '../shared/nuxi.3e6a21f5.mjs';
import { r as resolve, a as relative } from '../shared/nuxi.dcd5f40f.mjs';
import 'events';
import 'fs';
import 'path';
import 'util';
import 'stream';
import '../shared/nuxi.d1302898.mjs';
import 'os';
import 'node:fs';
import 'node:perf_hooks';
import '../shared/nuxi.a685c563.mjs';
import './satisfies.mjs';
import '../shared/nuxi.357b3b4e.mjs';
import '../shared/nuxi.cc8dd4a9.mjs';
import 'node:url';
import '../shared/nuxi.615ae2d1.mjs';
import 'node:module';
import '../shared/nuxi.2ec68044.mjs';
import 'node:assert';
import 'node:v8';
import '../shared/nuxi.3da669df.mjs';
import 'crypto';
import 'module';
import 'perf_hooks';
import 'vm';
import 'url';
import 'assert';
import 'process';
import 'v8';
import 'tty';
import 'node:stream';
import '../shared/nuxi.8d9be659.mjs';
import '../shared/nuxi.31a0124f.mjs';

const DEBOUNCE_DEFAULTS = {
  trailing: true
};
function debounce(fn, wait = 25, options = {}) {
  options = { ...DEBOUNCE_DEFAULTS, ...options };
  if (!Number.isFinite(wait)) {
    throw new TypeError("Expected `wait` to be a finite number");
  }
  let leadingValue;
  let timeout;
  let resolveList = [];
  let currentPromise;
  let trailingArgs;
  const applyFn = (_this, args) => {
    currentPromise = _applyPromised(fn, _this, args);
    currentPromise.finally(() => {
      currentPromise = null;
      if (options.trailing && trailingArgs && !timeout) {
        const promise = applyFn(_this, trailingArgs);
        trailingArgs = null;
        return promise;
      }
    });
    return currentPromise;
  };
  return function(...args) {
    if (currentPromise) {
      if (options.trailing) {
        trailingArgs = args;
      }
      return currentPromise;
    }
    return new Promise((resolve) => {
      const shouldCallNow = !timeout && options.leading;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const promise = options.leading ? leadingValue : applyFn(this, args);
        for (const _resolve of resolveList) {
          _resolve(promise);
        }
        resolveList = [];
      }, wait);
      if (shouldCallNow) {
        leadingValue = applyFn(this, args);
        resolve(leadingValue);
      } else {
        resolveList.push(resolve);
      }
    });
  };
}
async function _applyPromised(fn, _this, args) {
  return await fn.apply(_this, args);
}

const r=Object.create(null),t=e=>globalThis.process?.env||import.meta.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?r:globalThis),s=new Proxy(r,{get(e,o){return t()[o]??r[o]},has(e,o){const i=t();return o in i||o in r},set(e,o,i){const p=t(!0);return p[o]=i,!0},deleteProperty(e,o){if(!o)return !1;const i=t(!0);return delete i[o],!0},ownKeys(){const e=t(!0);return Object.keys(e)}}),E=typeof process<"u"&&process.env&&process.env.NODE_ENV||"",d=[["APPVEYOR"],["AZURE_PIPELINES","SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"],["AZURE_STATIC","INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"],["APPCIRCLE","AC_APPCIRCLE"],["BAMBOO","bamboo_planKey"],["BITBUCKET","BITBUCKET_COMMIT"],["BITRISE","BITRISE_IO"],["BUDDY","BUDDY_WORKSPACE_ID"],["BUILDKITE"],["CIRCLE","CIRCLECI"],["CIRRUS","CIRRUS_CI"],["CLOUDFLARE_PAGES","CF_PAGES",{ci:!0}],["CODEBUILD","CODEBUILD_BUILD_ARN"],["CODEFRESH","CF_BUILD_ID"],["DRONE"],["DRONE","DRONE_BUILD_EVENT"],["DSARI"],["GITHUB_ACTIONS"],["GITLAB","GITLAB_CI"],["GITLAB","CI_MERGE_REQUEST_ID"],["GOCD","GO_PIPELINE_LABEL"],["LAYERCI"],["HUDSON","HUDSON_URL"],["JENKINS","JENKINS_URL"],["MAGNUM"],["NETLIFY"],["NETLIFY","NETLIFY_LOCAL",{ci:!1}],["NEVERCODE"],["RENDER"],["SAIL","SAILCI"],["SEMAPHORE"],["SCREWDRIVER"],["SHIPPABLE"],["SOLANO","TDDIUM"],["STRIDER"],["TEAMCITY","TEAMCITY_VERSION"],["TRAVIS"],["VERCEL","NOW_BUILDER"],["VERCEL","VERCEL",{ci:!1}],["VERCEL","VERCEL_ENV",{ci:!1}],["APPCENTER","APPCENTER_BUILD_ID"],["CODESANDBOX","CODESANDBOX_SSE",{ci:!1}],["STACKBLITZ"],["STORMKIT"],["CLEAVR"]];function B(){if(globalThis.process?.env)for(const e of d){const o=e[1]||e[0];if(globalThis.process?.env[o])return {name:e[0].toLowerCase(),...e[2]}}return globalThis.process?.env?.SHELL==="/bin/jsh"&&globalThis.process?.versions?.webcontainer?{name:"stackblitz",ci:!1}:{name:"",ci:!1}}const I=B();I.name;function n(e){return e?e!=="false":!1}const l=globalThis.process?.platform||"",T=n(s.CI)||I.ci!==!1,a=n(globalThis.process?.stdout&&globalThis.process?.stdout.isTTY);n(s.DEBUG);const c=E==="test"||n(s.TEST);n(s.MINIMAL)||T||c||!a;const C=/^win/i.test(l);!n(s.NO_COLOR)&&(n(s.FORCE_COLOR)||C&&s.TERM!=="dumb"||a&&s.TERM&&s.TERM==="dumb"||T);const R=(globalThis.process?.versions?.node||"").replace(/^v/,"")||null;Number(R?.split(".")[0])||null;const Y=globalThis.process||Object.create(null),L={versions:{}};new Proxy(Y,{get(e,o){if(o==="env")return s;if(o in e)return e[o];if(o in L)return L[o]}});const _=!!globalThis.Netlify,O=!!globalThis.EdgeRuntime,D=globalThis.navigator?.userAgent==="Cloudflare-Workers",A=!!globalThis.Deno,u=!!globalThis.__lagon__,N=globalThis.process?.release?.name==="node",S=!!globalThis.Bun||!!globalThis.process?.versions?.bun,b=!!globalThis.fastly,K=[[_,"netlify"],[O,"edge-light"],[D,"workerd"],[A,"deno"],[u,"lagon"],[N,"node"],[S,"bun"],[b,"fastly"]];function F(){const e=K.find(o=>o[0]);if(e)return {name:e[1]}}const g=F();g?.name||"";

const RESTART_RE = /^(nuxt\.config\.(js|ts|mjs|cjs)|\.nuxtignore|\.nuxtrc)$/;
const devInternal = defineCommand({
  meta: {
    name: "_dev",
    description: "Run nuxt development server (internal command)"
  },
  args: {
    ...sharedArgs,
    ...legacyRootDirArgs
  },
  async run(ctx) {
    const logger = consola.withTag("nuxi");
    if (!process.send && !c) {
      logger.warn(
        "`nuxi _dev` is an internal command and should not be used directly. Please use `nuxi dev` instead."
      );
    }
    overrideEnv("development");
    const cwd = resolve(ctx.args.cwd || ctx.args.rootDir || ".");
    const {
      loadNuxt,
      buildNuxt,
      writeTypes: writeTypes$1 = writeTypes
    } = await loadKit(cwd);
    let serverHandler;
    const server = new Server((req, res) => {
      if (!serverHandler) {
        res.statusCode = 503;
        res.end("Nuxt is not ready yet!");
        return;
      }
      serverHandler(req, res);
    });
    const port = await new Promise((resolve2) => {
      server.listen(process.env._PORT || 0, () => {
        resolve2(server.address().port);
      });
    });
    const serverURL = `http://127.0.0.1:${port}/`;
    if (!process.send) {
      logger.success(`Listening on ${serverURL}`);
    }
    function sendIPCMessage(message) {
      if (process.send) {
        process.send(message);
      } else {
        logger.info(
          "Dev server event:",
          Object.entries(message).map((e) => e[0] + "=" + JSON.stringify(e[1])).join(" ")
        );
      }
    }
    let currentNuxt;
    let distWatcher;
    async function _load(reload, reason) {
      const action = reload ? "Restarting" : "Starting";
      const message = `${reason ? reason + ". " : ""}${action} nuxt...`;
      serverHandler = void 0;
      sendIPCMessage({
        type: "nuxt:internal:dev:loading",
        message
      });
      if (reload) {
        consola.info(message);
      }
      if (currentNuxt) {
        await currentNuxt.close();
      }
      if (distWatcher) {
        await distWatcher.close();
      }
      currentNuxt = await loadNuxt({
        rootDir: cwd,
        dev: true,
        ready: false,
        overrides: {
          logLevel: ctx.args.logLevel,
          vite: {
            clearScreen: ctx.args.clear
          },
          ...ctx.data?.overrides
        }
      });
      if (!reload) {
        const previousManifest = await loadNuxtManifest(
          currentNuxt.options.buildDir
        );
        const newManifest = await writeNuxtManifest(currentNuxt);
        if (previousManifest && newManifest && previousManifest._hash !== newManifest._hash) {
          await clearBuildDir(currentNuxt.options.buildDir);
        }
      }
      await currentNuxt.ready();
      const unsub = currentNuxt.hooks.hook("restart", async (options) => {
        unsub();
        if (options?.hard) {
          sendIPCMessage({ type: "nuxt:internal:dev:restart" });
          return;
        }
        await load(true);
      });
      const listenerInfo = JSON.parse(
        process.env.__NUXT_DEV_LISTENER__ || "null"
      ) || { url: serverURL, urls: [], https: false };
      await currentNuxt.hooks.callHook("listen", server, {
        // Internal server
        server,
        address: { host: "127.0.0.1", port },
        // Exposed server
        url: listenerInfo.url,
        https: listenerInfo.https,
        close: () => Promise.reject("Cannot close internal dev server!"),
        open: () => Promise.resolve(),
        showURL: () => Promise.resolve(),
        getURLs: () => Promise.resolve([
          ...listenerInfo.urls,
          { url: serverURL, type: "local" }
        ])
      });
      currentNuxt.options.devServer.url = `http://127.0.0.1:${port}/`;
      currentNuxt.options.devServer.host = "127.0.0.1";
      currentNuxt.options.devServer.port = port;
      currentNuxt.options.devServer.https = listenerInfo.https;
      await Promise.all([
        writeTypes$1(currentNuxt).catch(console.error),
        buildNuxt(currentNuxt)
      ]);
      distWatcher = chokidar.watch(
        resolve(currentNuxt.options.buildDir, "dist"),
        { ignoreInitial: true, depth: 0 }
      );
      distWatcher.on("unlinkDir", () => {
        loadDebounced(true, ".nuxt/dist directory has been removed");
      });
      serverHandler = toNodeListener(currentNuxt.server.app);
      sendIPCMessage({ type: "nuxt:internal:dev:ready", port });
    }
    async function load(reload, reason) {
      try {
        await _load(reload, reason);
      } catch (error) {
        consola.error(`Cannot ${reload ? "restart" : "start"} nuxt: `, error);
        serverHandler = void 0;
        const message = "Error while loading nuxt. Please check console and fix errors.";
        sendIPCMessage({ type: "nuxt:internal:dev:loading", message });
      }
    }
    const loadDebounced = debounce(load);
    const configWatcher = chokidar.watch([cwd], {
      ignoreInitial: true,
      depth: 0
    });
    configWatcher.on("all", (_event, _file) => {
      const file = relative(cwd, _file);
      if (file === (ctx.args.dotenv || ".env")) {
        return sendIPCMessage({ type: "nuxt:internal:dev:restart" });
      }
      if (RESTART_RE.test(file)) {
        loadDebounced(true, `${file} updated`);
      }
    });
    await load(false);
  }
});

export { devInternal as default };
